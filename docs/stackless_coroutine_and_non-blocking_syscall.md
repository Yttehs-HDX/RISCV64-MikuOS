# 无栈协程调度与非阻塞性系统调用

## 无栈协程调度

内核对进程进行调度，是协程调度的模型。

### 目的

有栈协程调度可以保存进程在 S 态的上下文，使得系统调用处理函数的实现变得简单，但是每一个进程就需要一个内核栈，带来了管理不便和内核栈管理的开销。

### 实现

无栈协程可以只使用一个内核栈，从 S 态回到 U 态后，内核栈的内容被弃用，内核栈会被反复使用。

## 非阻塞性系统调用

### 目的

采用无栈协程调度后，进程在 S 态不能保存当前的状态，也就是在内核调度后，进程不能恢复调度前的状态。研究发现，有且只有阻塞性系统调用，比如 waitpid、yield、nanosleep 等，才需要进程恢复阻塞之前的上下文。

如果能够让阻塞性系统调用变为及时性系统调用，就可以不用保存进程的上下文。

### 实现

> 这是一次大胆的尝试。

用户程序想要使用系统调用，需要把调用号和参数存储在 x17、x10 - x15，中，在中断后会保存在 TrapContext 中，用户使用 ecall 指令发出中断，进入内核。

当阻塞性系统调用满足非阻塞状态时，就是及时性的，当条件不满足时，**使 sepc 寄存器停留在 ecall 这条指令**，实现在用户层面的阻塞。对于之前的阻塞性系统调用，变为判断状态的即时性系统调用，不满足状态时进行调度，满足状态后再对 sepc 寄存器增加 4。
